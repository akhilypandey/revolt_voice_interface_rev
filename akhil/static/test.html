<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; max-width: 800px; margin: 0 auto; }
        .test-section { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; }
        .error { background: #f8d7da; color: #721c24; }
        .info { background: #d1ecf1; color: #0c5460; }
        button { padding: 10px 20px; margin: 5px; font-size: 16px; cursor: pointer; }
        #log { background: #f8f9fa; padding: 10px; border-radius: 5px; height: 300px; overflow-y: auto; font-family: monospace; }
        .mic-button { width: 80px; height: 80px; border-radius: 50%; border: none; background: #ef4444; color: white; font-size: 24px; }
        .mic-button.recording { background: #dc2626; animation: pulse 1s infinite; }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    </style>
</head>
<body>
    <h1>Voice Chat Test</h1>
    
    <div class="test-section">
        <h3>1. Connection Test</h3>
        <button onclick="testConnection()">Test WebSocket Connection</button>
        <div id="connection-status"></div>
    </div>
    
    <div class="test-section">
        <h3>2. Microphone Test</h3>
        <button onclick="testMicrophone()">Test Microphone Access</button>
        <div id="microphone-status"></div>
    </div>
    
    <div class="test-section">
        <h3>3. Voice Recording Test</h3>
        <button class="mic-button" id="testMic" onclick="toggleRecording()">
            <i class="fas fa-microphone"></i>
        </button>
        <div id="recording-status"></div>
    </div>
    
    <div class="test-section">
        <h3>4. Full Voice Chat Test</h3>
        <button onclick="testFullChat()">Test Complete Voice Chat</button>
        <div id="chat-status"></div>
    </div>
    
    <div class="test-section">
        <h3>Debug Log</h3>
        <button onclick="clearLog()">Clear Log</button>
        <div id="log"></div>
    </div>

    <script>
        let ws = null;
        let isRecording = false;
        let mediaRecorder = null;
        let audioChunks = [];
        
        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const timestamp = new Date().toLocaleTimeString();
            logDiv.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }
        
        function updateStatus(elementId, message, type = 'info') {
            const element = document.getElementById(elementId);
            element.innerHTML = `<div class="${type}">${message}</div>`;
        }
        
        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }
        
        function speakText(text) {
            if ('speechSynthesis' in window) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 0.9;
                utterance.pitch = 1.0;
                utterance.volume = 1.0;
                
                const voices = speechSynthesis.getVoices();
                const preferredVoice = voices.find(voice => 
                    voice.name.includes('Samantha') || 
                    voice.name.includes('Alex') || 
                    voice.name.includes('Google') ||
                    voice.name.includes('Natural')
                );
                
                if (preferredVoice) {
                    utterance.voice = preferredVoice;
                }
                
                utterance.onstart = () => log('üó£Ô∏è Rev started speaking');
                utterance.onend = () => log('‚úÖ Rev finished speaking');
                utterance.onerror = (event) => log(`‚ùå Speech error: ${event.error}`, 'error');
                
                window.speechSynthesis.speak(utterance);
            } else {
                log('‚ùå Text-to-speech not supported', 'error');
            }
        }
        
        function testConnection() {
            log('Testing WebSocket connection...');
            const clientId = 'test_' + Math.random().toString(36).substr(2, 9);
            ws = new WebSocket(`ws://localhost:8000/ws/${clientId}`);
            
            ws.onopen = () => {
                log('‚úÖ WebSocket connected successfully', 'success');
                updateStatus('connection-status', 'WebSocket connected successfully', 'success');
            };
            
            ws.onmessage = (event) => {
                log(`üì® Message received: ${event.data}`);
                const data = JSON.parse(event.data);
                if (data.type === 'pong') {
                    log('‚úÖ Ping/pong working');
                } else if (data.type === 'response_chunk') {
                    log(`üó£Ô∏è Rev speaking: ${data.text}`);
                    speakText(data.text);
                } else if (data.type === 'response_end') {
                    log('‚úÖ Rev finished speaking');
                }
            };
            
            ws.onerror = (error) => {
                log(`‚ùå WebSocket error: ${error}`, 'error');
                updateStatus('connection-status', 'WebSocket connection failed', 'error');
            };
            
            ws.onclose = () => {
                log('WebSocket connection closed');
            };
        }
        
        async function testMicrophone() {
            log('Testing microphone access...');
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });
                log('‚úÖ Microphone access granted', 'success');
                updateStatus('microphone-status', 'Microphone access granted', 'success');
                stream.getTracks().forEach(track => track.stop());
            } catch (error) {
                log(`‚ùå Microphone access failed: ${error.message}`, 'error');
                updateStatus('microphone-status', `Microphone access failed: ${error.message}`, 'error');
            }
        }
        
        async function toggleRecording() {
            if (isRecording) {
                stopRecording();
            } else {
                await startRecording();
            }
        }
        
        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                        log(`Audio chunk: ${event.data.size} bytes`);
                        
                        // Reset silence timer for auto-stop
                        if (window.silenceTimer) {
                            clearTimeout(window.silenceTimer);
                        }
                        
                        window.silenceTimer = setTimeout(() => {
                            if (isRecording) {
                                log('Auto-stopping recording after 2 seconds of silence');
                                stopRecording();
                            }
                        }, 2000);
                    }
                };
                
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    log(`‚úÖ Recording completed: ${audioBlob.size} bytes`, 'success');
                    updateStatus('recording-status', `Recording completed: ${audioBlob.size} bytes`, 'success');
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start();
                isRecording = true;
                document.getElementById('testMic').classList.add('recording');
                document.getElementById('testMic').innerHTML = '<i class="fas fa-stop"></i>';
                log('üé§ Recording started...');
                
            } catch (error) {
                log(`‚ùå Recording failed: ${error.message}`, 'error');
                updateStatus('recording-status', `Recording failed: ${error.message}`, 'error');
            }
        }
        
        function stopRecording() {
            if (mediaRecorder && isRecording) {
                if (window.silenceTimer) {
                    clearTimeout(window.silenceTimer);
                }
                mediaRecorder.stop();
                isRecording = false;
                document.getElementById('testMic').classList.remove('recording');
                document.getElementById('testMic').innerHTML = '<i class="fas fa-microphone"></i>';
                log('‚èπÔ∏è Recording stopped');
            }
        }
        
        async function testFullChat() {
            log('Testing complete voice chat...');
            
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                log('‚ùå WebSocket not connected. Please test connection first.', 'error');
                updateStatus('chat-status', 'WebSocket not connected', 'error');
                return;
            }
            
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 16000,
                        channelCount: 1,
                        echoCancellation: true,
                        noiseSuppression: true
                    } 
                });
                
                const mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus'
                });
                
                const audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        audioChunks.push(event.data);
                    }
                };
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    log(`Processing ${audioBlob.size} bytes of audio...`);
                    
                    const reader = new FileReader();
                    reader.onload = () => {
                        const base64Audio = reader.result.split(',')[1];
                        log(`Sending audio to server...`);
                        
                        const message = {
                            type: 'audio',
                            audio_data: base64Audio,
                            mime_type: 'audio/webm'
                        };
                        
                        ws.send(JSON.stringify(message));
                        log('‚úÖ Audio sent to server');
                        updateStatus('chat-status', 'Audio sent to server - waiting for response...', 'info');
                    };
                    
                    reader.readAsDataURL(audioBlob);
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.start();
                log('üé§ Recording for chat test... (will stop in 3 seconds)');
                
                setTimeout(() => {
                    mediaRecorder.stop();
                }, 3000);
                
            } catch (error) {
                log(`‚ùå Chat test failed: ${error.message}`, 'error');
                updateStatus('chat-status', `Chat test failed: ${error.message}`, 'error');
            }
        }
        
        // Auto-run connection test
        window.onload = () => {
            log('Page loaded - ready for testing');
            testConnection();
        };
    </script>
</body>
</html>
